// This override skips the "Patching ..." message if the script is run in silent mode.
/**
 * Adds an item to the current STO file. This is a PATCH function.
 * SET charge1          Number charges of the 1st ability or quantity for stackables. (Default: 0)
 * SET charge2          Number charges of the 2nd ability. (Default: 0)
 * SET charge3          Number charges of the 3rd ability. (Default: 0)
 * SET stack            Number of item instances the store carries in the stack. (Default: 1)
 * SET unlimited        Set to non-zero if the store should carry an inexhaustible stack of the new item. (Default: 0)
 * SET overwrite        Set to non-zero to overwrite any instances of an existing sale entry of matching item resref
 *                      when found. (Default: 0)
 * SET expiration       The item's expiration time, when it will be replaced with the drained item. (Default: 0)
 * SPRINT item_name     The resource name (resref) of the item to add.
 * SPRINT position      Desired position of the item in the list of sale entries. The following syntax is supported:
 *                      AFTER resref    Will place the new item directly behind the item given by "resref".
 *                                      You can list more than one resref, separated by space. The new item will be
 *                                      added after the entry of the first matching resref.
 *                      BEFORE resref   Will place the new item directly before the item given by "resref".
 *                                      You can list more than one resref, separated by space. The new item will be
 *                                      added before the entry of the first matching resref.
 *                      LAST            Will place the new item after all existing items.
 *                      FIRST           Will place the new item before all existing items.
 *                      AT value        Will place the new item at the position given by the number "value".
 *                                      Use negative values to place the new item relative to the last item position
 *                                      in reverse order.
 *                      (Default: FIRST)
 * SPRINT flags         Use numeric values or the following constants: none, identified, unstealable, stolen.
 *                      Constants can be combined by using ampersand (&) or space as separators
 *                      (e.g. identified&unstealable). (Default: none)
 * SPRINT sale_trigger  Availability trigger (STO V1.1 only). The following syntax is supported:
 *                      Trigger string          Example: GlobalGT("MyCondition","GLOBAL",0)
 *                      Strref value            Example: #1234
 *                      Translation reference   Example: @1000
 *                      (Default: #-1)
 * RETURN index         Index of the added item or the last matching index when overwriting items.
 *                      Returns -1 if the item could not be added or updated.
 * RETURN offset        Offset of the added item or the last matching offset when overwriting items.
 *                      Returns -1 if the item could not be added or updated.
 */
DEFINE_PATCH_FUNCTION ~ADD_STORE_ITEM_EX~
INT_VAR
  charge1       = 0
  charge2       = 0
  charge3       = 0
  stack         = 1
  expiration    = 0
  unlimited     = 0
  overwrite     = 0
STR_VAR
  item_name     = ~~
  position      = ~FIRST~
  flags         = ~none~
  sale_trigger  = ~#-1~
RET
  index
  offset
BEGIN
  SET index = "-1"
  SET offset = "-1"

  // Initializations
  LPF ~__A7_VALIDATE_STORE~
  STR_VAR warn_prefix = ~ADD_STORE_ITEM_EX~
  RET
    failed
    version
    HEADER_SIZE = header_size
    SALE_SIZE = sale_size
    DRINK_SIZE = drink_size
  END

  PATCH_IF (NOT failed) BEGIN
    READ_LONG 0x34 ofs_sales
    READ_LONG 0x38 num_sales

    PATCH_IF (num_sales = 0 && ofs_sales < HEADER_SIZE) BEGIN
      // Default order of sections: Drinks < Sales < Cures < Purchases
      READ_LONG 0x4c ofs  // drinks
      PATCH_IF (ofs >= HEADER_SIZE) BEGIN
        READ_LONG 0x50 num
        SET size = DRINK_SIZE
      END

      PATCH_IF (ofs >= HEADER_SIZE) BEGIN
        SET ofs_sales = ofs + num * size
      END ELSE BEGIN
        SET ofs_sales = HEADER_SIZE
      END
      WRITE_LONG 0x34 ofs_sales
    END

    // Preparing arguments
    PATCH_IF (NOT ~%item_name%~ STR_EQ ~~) BEGIN
      TO_UPPER ~item_name~
    END ELSE BEGIN
      PATCH_WARN ~ADD_STORE_ITEM_EX: item_name is empty.~
    END

    LPF ~__A7_EVAL_ITEM_FLAGS~
    STR_VAR
      flags
      warn_prefix = ~ADD_STORE_ITEM_EX~
    RET
      item_flags = value
    END

    PATCH_IF (version = 11 && NOT ~%sale_trigger%~ STR_EQ ~~) BEGIN
      LPF ~__A7_RESOLVE_STRREF~
      STR_VAR string = EVAL ~%sale_trigger%~
      RET item_trigger = strref
      END

      // Performing syntax check
      GET_STRREF item_trigger trigger_string
      PATCH_IF (NOT VALID_SCRIPT_TRIGGERS ~%trigger_string%~) BEGIN
        SET item_trigger = "-1"
        PATCH_WARN ~ADD_STORE_ITEM_EX: sale_trigger contains invalid code - defaulting to empty trigger.~
      END
    END ELSE BEGIN
      SET item_trigger = "-1"
    END

    SET unlimited = unlimited ? 1 : 0

    PATCH_IF (overwrite) BEGIN
      // Updating existing entries of matching item resref
      FOR (idx = 0; idx < num_sales; ++idx) BEGIN
        SET ofs = ofs_sales + idx * SALE_SIZE
        READ_ASCII ofs resref (8) NULL
        PATCH_IF (~%resref%~ STR_EQ ~%item_name%~) BEGIN
          WRITE_SHORT (ofs + 0x08) expiration
          WRITE_SHORT (ofs + 0x0a) charge1
          WRITE_SHORT (ofs + 0x0c) charge2
          WRITE_SHORT (ofs + 0x0e) charge3
          WRITE_LONG (ofs + 0x10) item_flags
          WRITE_LONG (ofs + 0x14) stack
          WRITE_LONG (ofs + 0x18) unlimited
          PATCH_IF (version = 11) BEGIN
            WRITE_LONG (ofs + 0x1c) item_trigger
          END
          SET index = idx
          SET offset = ofs
        END
      END
    END

    PATCH_IF (index < 0) BEGIN
      SET found = 0
      FOR (idx = 0; idx < num_sales; ++idx) BEGIN
        READ_ASCII (ofs_sales + idx * SALE_SIZE) resref (8) NULL
        PATCH_IF (~%resref%~ STR_EQ ~%item_name%~) BEGIN
          SET found = 1
          SET idx = num_sales
        END
      END

      PATCH_IF (NOT found) BEGIN
        // Adding new sale entry
        PATCH_IF NOT IS_SILENT BEGIN
            PATCH_PRINT ~Patching %item_name%.ITM into store...~
        END
        LPF ~__A7_EVAL_POSITION~
        INT_VAR
          num_entries = num_sales
          ofs_entries = ofs_sales
          size_entry  = SALE_SIZE
          ofs_resref  = 0
        STR_VAR
          position
          position_default  = ~FIRST~
          warn_prefix       = ~ADD_STORE_ITEM_EX~
        RET
          item_position = entry_position
        END

        PATCH_IF (item_position >= 0) BEGIN
          SET ofs = ofs_sales + item_position * SALE_SIZE
          INSERT_BYTES ofs SALE_SIZE
          WRITE_ASCIIE ofs ~%item_name%~ (8)
          WRITE_SHORT (ofs + 0x08) expiration
          WRITE_SHORT (ofs + 0x0a) charge1
          WRITE_SHORT (ofs + 0x0c) charge2
          WRITE_SHORT (ofs + 0x0e) charge3
          WRITE_LONG (ofs + 0x10) item_flags
          WRITE_LONG (ofs + 0x14) stack
          WRITE_LONG (ofs + 0x18) unlimited
          PATCH_IF (version = 11) BEGIN
            WRITE_LONG (ofs + 0x1c) item_trigger
          END
          SET index = item_position
          SET offset = ofs

          // Updating item sale count and remaining offsets
          WRITE_LONG 0x38 (num_sales + 1)
          LPF ~__A7_UPDATE_OFFSETS~
          INT_VAR
            value = SALE_SIZE
            skip_offset = 0x34
          END
        END ELSE BEGIN
          PATCH_WARN ~ADD_STORE_ITEM_EX: Could not determine item position.  Skipping...~
        END
      END ELSE BEGIN
        PATCH_PRINT ~%item_name%.ITM is already in the store.  Skipping...~
      END
    END
  END
END
